package main

import (
	"slices"
	"strings"
)

/*
=== Поиск анаграмм по словарю ===

Написать функцию поиска всех множеств анаграмм по словарю.
Например:
	'пятак', 'пятка' и 'тяпка' - принадлежат одному множеству,
	'листок', 'слиток' и 'столик' - другому.

Требования:
- Входные данные для функции: ссылка на массив, каждый элемент которого - слово на русском языке в кодировке utf8.
- Выходные данные: ссылка на мапу множеств анаграмм.
- Ключ - первое встретившееся в словаре слово из множества. Значение - ссылка на массив, каждый элемент которого, слово из множества.
- Массив должен быть отсортирован по возрастанию.
- Множества из одного элемента не должны попасть в результат.
- Все слова должны быть приведены к нижнему регистру.
- В результате каждое слово должно встречаться только один раз.
*/

// Функция поиска всех множеств анаграмм.
func SearchAnagramms(words []string) map[string][]string {
	// Сортируем срез слов, чтобы слова добавлялись во множества по возрастанию.
	slices.Sort(words)

	// Создаем "грязную" мапу множеств анаграмм.
	dirty := make(map[string][]string)

	for _, word := range words {
		lowerWord := strings.ToLower(word) // неотсортированное слово, приведенное к нижнему регистру
		unsortedWord := []rune(lowerWord)  // представление неотсортированного слова в виде рун

		// Сортируем руны неотсортированного слова
		slices.Sort(unsortedWord)
		sortedWord := string(unsortedWord) // представление отсортированного слова в виде строки

		// Добавляем неотсортированное слово во множество.
		dirty[sortedWord] = append(dirty[sortedWord], lowerWord)
	}

	// Создаем "чистую" мапу множеств анаграмм
	// с правильными ключами и без множеств, состоящих из одного элемента.
	clean := make(map[string][]string)

	// Заполняем "чистую" мапу множеств анаграмм.
	for _, words := range dirty {
		if len(words) > 1 {
			clean[words[0]] = words
		}
	}

	return clean
}
